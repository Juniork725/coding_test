## 문제: 징검다리 건너기 (https://school.programmers.co.kr/learn/courses/30/lessons/64062)
```python
from collections import deque
def solution(stones, k):
    dq = deque([])
    answer = 999999999
    for i,v in enumerate(stones):
        if dq and i-dq[0] == k:
            dq.popleft()
        while dq and v >= stones[dq[-1]]:
            dq.pop()
        dq.append(i)
        
        if i >= k-1:
            answer = min(answer, stones[dq[0]])
    return answer
```
각각 밟을 수 있는 횟수가 정해진 돌들로 이뤄진 징검다리가 있다. 다음 돌이 비어있어도 최대 k칸까지는 뛰어넘을 수 있을 때, 징검다리를 모두 건널 수 있는 최대 인원수를 구하는 문제다.    

문제를 보고 최대 인원수가 어떤 조건을 만족하는지부터 확인했다. 길이가 k인 임의의 구간의 최댓값이 M이라면, 해당 구간은 최대 M명만 통과할 수 있다. M명이 통과하면 해당 구간은 모두 0이 되고, M+1번째 사람은 최소 k+1개의 돌을 뛰어넘어야 하기 때문이다.   
즉, 징검다리를 통과하는 최대 인원수는 길이가 k인 모든 구간의 최댓값 중 최솟값이다.   
때문에 sliding window를 움직이면서 최댓값을 확인하고, 그 값들의 최솟값을 반환하면 되겠다고 생각했다.   

하지만 window의 최댓값을 효율적으로 계산할 방법이 떠오르지 않아서 효율성 문제 1개를 계속 통과하지 못하다가 결국 구글링을 해서 힌트를 얻었다.   
max sliding window라는 기법으로, sliding window를 움직이며 해당 구간의 최댓값들을 구할 수 있는 기법이다.   
특이한 점은 deque 내에 값 대신 index를 저장하고, 해당 index의 값을 기준으로 pop 연산을 한다는 것이다. deque 내에 window의 모든 값을 저장하는 게 아니라, 최댓값의 후보가 될 값들만 저장한다. 때문에 window의 길이를 일정하게 유지하기 위해 index를 저장하고 이것이 현재보다 k 이상 떨어져있으면 pop을 하는 것이다.   
최댓값의 후보가 될 값을 남기기 위해, 지금 추가하려는 값보다 작거나 같은 값들은 모두 pop을 하고 자신을 우측에 삽입한다. 이러면 자연스럽게 deque가 항상 내림차순으로 정렬된 상태를 유지한다.   
내림차순 정렬을 유지하기 때문에, window의 크기를 k로 유지하는 과정에서 왼쪽 값을 pop하면 자연스럽게 남은 값 중 최댓값이 가장 왼쪽으로 온다.   
때문에 매번 dq[0]에 접근하면 해당 window의 최댓값을 얻을 수 있는 것이다.   

처음에 최대 인원수의 조건을 먼저 찾고 이 조건을 구현하려고 하다 보니 조금 어렵게 풀었다. 사실 통과할 수 있는 인원수 m에 대해 이진탐색을 하며 k개 이상 연속으로 m보다 작은 구간이 있는지 확인하는 방법도 있다.   
위의 풀이는 n은 돌의 수, m은 돌의 최댓값일 때 O(n)이고 이진탐색은 O(nlogm)이기에 위의 풀이가 더 효율적이긴 하다. 하지만 실제 코딩 테스트였다면 두 방법 모두 정답이 되기에 더 구현이 쉬운 이진탐색을 시도하는 게 맞았을 듯하다.   
실제 테스트에서는 원래 풀이가 막히면 다른 방법으로 풀 수는 없을지 고민해보는 것도 좋겠다.   
