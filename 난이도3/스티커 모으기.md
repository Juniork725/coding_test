## 문제: 110 옮기기 (https://school.programmers.co.kr/learn/courses/30/lessons/1881)
```python
def solution(sticker):
    l = len(sticker)
    if l <= 2:
        return max(sticker)
    
    dp1 = [sticker[0],max(sticker[0],sticker[1])]
    dp2 = [0,sticker[1]]
    for i in range(2,l-1):
        dp1.append(max(dp1[-2]+sticker[i],dp1[-1]))
        dp2.append(max(dp2[-2]+sticker[i],dp2[-1]))
    dp2.append(max(dp2[-2]+sticker[-1],dp2[-1]))
    
    return max(dp1[-1],dp2[-1])
```
자연수가 적힌 n개의 스티커가 원형으로 연결되어 있다. 한 스티커를 뜯으면 양쪽의 스티커는 찢어져 없어진다.  
뜯어낸 스티커에 적힌 수의 합을 최대로 하는 경우를 찾는 문제다.  

신경써야 할 부분이 2가지 있다. 스티커가 원형으로 연결되어 있다는 점과 하나를 뜯으면 양쪽은 뜯을 수 없다는 점이다.  
2가지만 잘 고려하면 DP로 간단히 해결할 수 있다.  
dp[i]를 i번째 스티커까지 규칙에 맞게 뜯었을 때 최대값이라 하자.  
dp[i]는 i번째 스티커를 뜯는 경우와 뜯지 않는 경우 중 더 큰 값이다.  
i번째 스티커를 뜯지 않는 경우 dp[i-1]을 그대로 가져오면 된다.  
i번째 스티커를 뜯는 경우 dp[i-2] + sticker[i]가 된다. i-1번째 스티커를 뜯었다면 i번째는 뜯을 수 없기 때문이다.  
dp[i-1]이 i-1번재 스티커를 뜯지 않은 경우라고 하더라도 이때의 값은 dp[i-2]와 같으므로 추가적으로 고려할 필요는 없다.  

위 과정을 계속 반복하여 dp를 갱신해나가되, 마지막 스티커는 예외적인 고려가 필요하다.  
첫 스티커를 뗀 경우와 아닌 경우에 따라 달라지기 때문이다.  
때문에 첫 스티커를 뗀 경우인 dp1과 떼지 않은 경우인 dp2로 나누어 계산한다.  
dp1에서는 마지막 스티커를 뗄 수 없으므로 dp1[-1]이 최대값이 된다.  
dp2에서는 마지막 스티커를 떼는 것이 가능하므로 dp를 한 번 더 갱신해준다.  
두 dp의 마지막 값 중 더 큰 값을 반환하면 된다.  
