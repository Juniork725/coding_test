## 문제: 파괴되지 않은 건물 (https://school.programmers.co.kr/learn/courses/30/lessons/92344)


```python
def solution(board, skill):
    answer = 0
    prefix_sum = [[0]*(len(board[0])+1) for _ in range(len(board)+1)]
    for s in skill:
        [type, r1, c1, r2, c2, degree] = s
        if type == 1:
            degree *= -1
        prefix_sum[r1][c1] += degree
        prefix_sum[r1][c2+1] -= degree
        prefix_sum[r2+1][c1] -= degree
        prefix_sum[r2+1][c2+1] += degree
        
    for i in range(len(prefix_sum)):
        for j in range(1,len(prefix_sum[0])):
            prefix_sum[i][j] += prefix_sum[i][j-1]
    for i in range(1,len(prefix_sum)):
        for j in range(len(prefix_sum[0])):
            prefix_sum[i][j] += prefix_sum[i-1][j]
            
    for i in range(len(board)):
        for j in range(len(board[0])):
            if board[i][j] + prefix_sum[i][j] > 0:
                answer += 1
    return answer
```

간단한 반복 연산을 위한 어려운 풀이가 필요했다.  
정확성 테스트는 브루트 포스 방식으로 풀어도 쉽게 통과할 수 있다. 애초에 문제의 디자인이 단순해서 구현도 간단하다.  
문제는 효율성 테스트이다. 넓은 2차원 영역 중 일부 구간들에 대한 반복적인 연산을 효율적으로 처리해야 했다.  
어떻게 하면 연산을 줄일 수 있을지 생각하며 행이나 열을 묶어서 한 번에 처리할 수 있는 방법 등을 고민해봤는데 딱히 수가 떠오르지 않았다.  
결국 이번에도 카카오 테크 블로그를 참고해서 풀었다.  
  
이번 문제를 풀기 위해서는 누적 합이라는 것이 필요하다고 한다.  
누적 합의 개념을 처음 들어봐서 조금 찾아봤는데, 어떤 배열에 대해 일정 구간들의 합을 반복적으로 구하고 싶을 때 활용한다고 한다.  
원래의 배열 A보다 크기가 1만큼 큰 배열 S를 만들고, A[0]~A[i]의 합을 S[i+1]에 저장하는 것이다.  
S를 위와 같은 조건으로 만드는 이유는 S[i] + A[i] = S[i+1]임을 이용하여 빠르게 S를 구할 수 있기 때문이다.  
여기서 직전 값인 S[i]를 이용해 S[i+1]을 구하는 방식을 이용한다.  
  
skill의 각 원소에서 요구하는 연산을 직접 수행하려면 O(NM)을 요구한다.  
그러나 연산이 필요한 구간의 시작지점과 종료지점만을 표시한다면 O(1)으로 해결할 수 있다.  
예를 들어 길이가 4인 배열의 1번째부터 3번째 원소까지 1을 더하고 싶다면,  
[1,0,0,-1,0]과 같은 배열을 만든 후 누적합을 구해주면 [1,1,1,0,0]이 된다.  
주의할 점은 연산을 할 구간의 종료지점 바로 다음 자리에 필요한 연산량의 반대를 기록해야 한다는 것이다.  
이렇게 시작지점과 종료지점만을 표시해 뒀다가 누적합을 하면 각 원소에 필요한 연산값이 된다.  
물론 누적합을 하는 것 역시 O(NM)을 요구한다.  
그러나 skill 연산들을 각각 누적합하여 합친 것과, 누적합 이전의 배열을 모두 합한 다음 누적합을 한 결과는 같다.  
따라서 변화량을 기록하기 위한 배열을 하나 만든 후,  
각각의 skill마다 시작지점과 종료지점을 표시하는 연산을 하고,  
마지막에 누적합을 하면 각 원소의 변화량을 구할 수 있으며, 이때의 시간복잡도는 O(K+NM)이다. (K는 skill의 길이)  
  
여기서 신경써야 할 점은 문제의 조건이 2차원 배열이라는 것이다.  
각 행마다 시작지점에 해당하는 열에 표시를 하고 마지막에 행의 누적합을 구할 수도 있으나, 이렇게 하면 O(KN+NM)이 된다.  
대신에 (r1,c1), (r1,c2+1), (r2+1,c1), (r2+1,c2+1)에 표시를 하고 행의 누적합, 열의 누적합을 순서대로 구하면 O(K+NM)으로 해결할 수 있다.  
이때 (r1,c1)과 (r2+1,c2+1)에는 변화량과 같은 값을, 나머지 자리에는 반대 부호의 값을 기록해야 한다.  
이렇게 처리하고 누적합을 구하면 (r1,c1)~(r2,c2)까지 원하는 변화량이 기록된다.  
  
코드에서 마지막에 각 행의 누적합을 구한 뒤 열의 누적합을 구하기 위해 board 전체를 2번 순회했다.  
하지만 1행의 누적합과 1열의 누적합을 구한 뒤 2행 2열부터 board[i][j] += board[i-1][j] + board[i][j-1] - board[i-1][j-1]로 구할 수도 있다.  
board[i][j]는 [0][0]부터 [i][j]까지 직사각형 구간의 누적합이기 때문이다.  
이렇게 구하면서 board[i][j]가 양수인지도 확인하면 원래 코드에서 board를 총 3번 순회한 것을 1번으로 줄일 수 있다.  
  
이번 문제는 누적합이라는 개념을 알고 있지 않으면 아이디어를 떠올리기 상당히 어려울 것 같다.  
처음 활용한 개념이라 아직 생소하지만, 누적합의 연산 방식, 그리고 누적합을 응용하면 배열의 특정 구간들에 대한 반복적인 연산을 빠르게 처리할 수 있다는 점을 기억해둬야겠다.
